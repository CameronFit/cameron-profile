{
  "badges": [
    { "icon": "bolt", "text": "Signals" },
    { "icon": "sync_lock", "text": "Interceptors" },
    { "icon": "admin_panel_settings", "text": "Guards" },
    { "icon": "extension", "text": "InjectionTokens" },
    { "icon": "fact_check", "text": "Testable" },
    { "icon": "palette", "text": "Material M3" }
  ],
  "folders": [
    {
      "path": "src/core",
      "why": "Cross-cutting: interceptors, guards, tokens, shared services."
    },
    {
      "path": "src/shared",
      "why": "Presentational components, CVA controls, pipes, utilities."
    },
    {
      "path": "src/features/public",
      "why": "Unprotected pages: Home, Profile, Projects."
    },
    {
      "path": "src/features/admin",
      "why": "Guarded area: role-aware widgets, admin tools."
    },
    {
      "path": "src/app-shell",
      "why": "Topbar, sidenav, shell layout with signals."
    }
  ],
  "whatWhy": [
    {
      "title": "Standalone Components",
      "body": "No NgModule bloat. Each feature declares its own imports for faster startup and clear boundaries."
    },
    {
      "title": "Signals (App State)",
      "body": "Simple, explicit state for UI + session. Use RxJS for streams/IO, signals for local UI."
    },
    {
      "title": "Interceptors & Guards",
      "body": "Centralize cross-cutting logic and keep routes honest with canMatch."
    },
    {
      "title": "InjectionTokens",
      "body": "Like labeled sockets â€” plug different implementations for tests/env."
    },
    {
      "title": "Material M3 + Tokens",
      "body": "Accessible UI with consistent radii, spacing, shadows, and colors."
    },
    {
      "title": "Production Auth",
      "body": "Access token in memory; refresh via HttpOnly cookie; safe startup refresh & replay."
    }
  ],
  "snippets": {
    "guard": "import { inject } from '@angular/core';\nimport { CanMatchFn, Route } from '@angular/router';\nimport { AUTH_STATE } from '../core/tokens';\n\nexport const authGuard: CanMatchFn = (route: Route) => {\n  const auth = inject(AUTH_STATE);\n  if (!auth.isAuthenticated()) {\n    auth.redirectToLogin(route.path ?? '/admin');\n    return false;\n  }\n  return true;\n};",
    "authInterceptor": "import { HttpInterceptorFn, HttpRequest, HttpHandlerFn, HttpErrorResponse } from '@angular/common/http';\nimport { inject, signal } from '@angular/core';\nimport { AUTH_STATE } from '../core/tokens';\nimport { catchError, firstValueFrom, throwError } from 'rxjs';\n\nconst refreshing = signal(false);\nlet queue: ((t: string | null) => void)[] = [];\n\nexport const authInterceptor: HttpInterceptorFn = (req: HttpRequest<unknown>, next: HttpHandlerFn) => {\n  const auth = inject(AUTH_STATE);\n  const token = auth.accessToken();\n  const authed = token ? req.clone({ setHeaders: { Authorization: `Bearer ${token}` } }) : req;\n  return next(authed).pipe(\n    catchError((err: HttpErrorResponse) => {\n      if (err.status === 401) {\n        return firstValueFrom(refreshIfNeeded(auth)).then((newToken) => {\n          const retry = newToken ? authed.clone({ setHeaders: { Authorization: `Bearer ${newToken}` } }) : authed;\n          return next(retry).toPromise();\n        });\n      }\n      return throwError(() => err);\n    })\n  );\n};\n\nfunction refreshIfNeeded(auth: any) {\n  return new Promise<string | null>((resolve) => {\n    queue.push(resolve);\n    if (refreshing()) return;\n    refreshing.set(true);\n    auth.refresh().finally(() => {\n      refreshing.set(false);\n      const t = auth.accessToken();\n      queue.forEach((fn) => fn(t));\n      queue = [];\n    });\n  });\n}",
    "loadingInterceptor": "import { HttpInterceptorFn } from '@angular/common/http';\nimport { inject } from '@angular/core';\nimport { APP_LOADING } from '../core/tokens';\nimport { finalize } from 'rxjs/operators';\n\nexport const loadingInterceptor: HttpInterceptorFn = (req, next) => {\n  const loading = inject(APP_LOADING);\n  loading.set(true);\n  return next(req).pipe(finalize(() => loading.set(false)));\n};",
    "errorInterceptor": "import { HttpErrorResponse, HttpInterceptorFn } from '@angular/common/http';\nimport { inject } from '@angular/core';\nimport { APP_NOTIFIER } from '../core/tokens';\nimport { catchError, throwError } from 'rxjs';\n\nexport const errorInterceptor: HttpInterceptorFn = (req, next) => {\n  const notify = inject(APP_NOTIFIER);\n  return next(req).pipe(\n    catchError((err: HttpErrorResponse) => {\n      const message = err.error?.message || 'Something went wrong. Please try again.';\n      notify.error(message);\n      return throwError(() => err);\n    })\n  );\n};",
    "authState": "import { InjectionToken, signal } from '@angular/core';\n\nexport interface AuthState {\n  accessToken: ReturnType<typeof signal<string | null>>;\n  user: ReturnType<typeof signal<{ id: string; roles: string[] } | null>>;\n  isAuthenticated: () => boolean;\n  hasRole: (role: string) => boolean;\n  setToken: (t: string | null) => void;\n  logoutLocal: () => void;\n  redirectToLogin: (returnUrl?: string) => void;\n  refresh: () => Promise<void>;\n}\n\nexport const AUTH_STATE = new InjectionToken<AuthState>('AUTH_STATE', {\n  providedIn: 'root',\n  factory: () => {\n    const accessToken = signal<string | null>(null);\n    const user = signal<{ id: string; roles: string[] } | null>(null);\n\n    return {\n      accessToken,\n      user,\n      isAuthenticated: () => !!accessToken(),\n      hasRole: (role: string) => !!user()?.roles?.includes(role),\n      setToken: (t) => accessToken.set(t),\n      logoutLocal: () => { accessToken.set(null); user.set(null); },\n      redirectToLogin: (returnUrl?: string) => { window.location.href = `/login?returnUrl=${encodeURIComponent(returnUrl || '/')}`; },\n      refresh: async () => { /* call /auth/refresh (HttpOnly cookie), then set accessToken */ }\n    };\n  }\n});",
    "widgetToken": "import { InjectionToken, Type } from '@angular/core';\nexport interface WidgetDef { id: string; title: string; component: Type<any>; roles?: string[]; }\nexport const DASHBOARD_WIDGETS = new InjectionToken<WidgetDef[]>('DASHBOARD_WIDGETS', {\n  providedIn: 'root',\n  factory: () => []\n});",
    "signalsVsBs": "import { signal, computed } from '@angular/core';\nconst items = signal<number[]>([]);\nconst count = computed(() => items().length);\nfunction add(n: number) { items.update(a => [...a, n]); }",
    "routes": "import { Routes } from '@angular/router';\nimport { authGuard } from './core/auth.guard';\nexport const routes: Routes = [\n  { path: '', loadComponent: () => import('./features/public/home/home.component').then(m => m.HomeComponent), title: 'Home' },\n  { path: 'admin', canMatch: [authGuard], loadComponent: () => import('./features/admin/admin-shell.component').then(m => m.AdminShellComponent), title: 'Admin' },\n  { path: '**', redirectTo: '' }\n];"
  }
}
